(**
   This module offers an higher level api over Ocaml_dynloader.
   This retrieves the compiler and a bunch of cmi files embedded in the current
   executable, and use them to do the compilation of ocaml source files,
   before loading them using Dynlink. The compilation steps happen in Async.

   This is meant to be used in unix only, in particular because it uses /proc to
   determine the location of the exec code being run.
*)
open Core.Std
open Async.Std

(**
   mutable type to get the compiler and the cmi using the objcopy section
   which must have been embedded in the executable by 'ocaml-embed-compiler'
*)
type t

(**
   This is the convention over the name of the embedded section's name.
   The executable should contain such a section, or this module
   won't work. The convention is that this should be tgz file.
*)
val section_id : string

(**
   The convention over the name of pervasives inside the archive
*)
val pervasives : string

val config_file : string

(**
   This returns the complete path of the code file beeing executed by
   the current pid, i.e. the file containing the current program's binary.
   This returns a Deferred.t because the implementation may need to interact
   with the file system.
   Although the current implementation doesn't, we do not want to change
   the interface if this interaction becomes mandatory at some point.
*)
val get_my_code_file : unit -> string Deferred.t

type 'a create_arguments =
  ?code_file : [`my_code | `file of string]
  -> 'a Ocaml_dynloader.create_arguments

(**
   This is a special utilisation of the Generic Loader.
   This uses some assumptions, such as a file called ocamlopt.opt
   is present in the archive, as well as some cmi files,
   and uses a tmp compilation_directory.
   A call to this function will retrieve the embedded part of the code,
   and extract it in the current corresponding directory.
   The most common use and the default value for [code_file] is [`my_code].
   Currently this library works with native code only. Called in bytecode,
   this function will return the exception [Ocaml_dynloader.Is_not_native]
   See the documentation of ocaml_dynloader for other flags, they are
   passed internally to that module to create the internal dynloader
   (in _dir, custom_warnings_spec, etc.).

   /!\ By using this manual create, you take the responsibility to call [clean t] when
   you're done with all the compilation that you want to do with this compiler.  Consider
   using [with_compiler], [Make] or [load_ocaml_src_files] if this makes your life
   simpler.
*)
val create : (
  unit -> [`this_needs_manual_cleaning_after of t] Deferred.Or_error.t
) create_arguments

(**
   Call create, do something with the compiler, and then take care of calling clean.
*)
val with_compiler : (
  unit -> f:(t -> 'a Deferred.Or_error.t) -> 'a Deferred.Or_error.t
) create_arguments

(**
   Get the loader using this compiler and these cmi
*)
val loader : t -> Ocaml_dynloader.t

(**
   This forces the initialization setup (tempdir, extraction)
*)
val force_val : t -> unit Deferred.Or_error.t

(**
   This allow you to know the list of the filename contained in the archive.
   This forces the initialization setup (tempdir, extraction)
*)
val files : t -> string list Deferred.Or_error.t


(**
   If for some reason you need to know where everything happens.
   This directory is an absolute pathname.
   This forces the initialization setup (tempdir, extraction).
   see also lazy_directory.
*)
val directory : t -> string Deferred.Or_error.t

(**
   returning both at the same time
*)
val directory_files : t -> (string * string list) Deferred.Or_error.t

(**
   This deferred gets computed once the setup has been achieved.
   Useful for logging/debugging purpose. Beware, if no compilation happen,
   this deferred may never get computed.
*)
val read_directory : t -> string Deferred.Or_error.t

(**
   This will delete the temporary directory created, and remove all
   the files, included the files generated by the loader.
   This function should be used when the compiler has been created using [create] for
   advanced use of this module. For a simpler usage, look at [with_compiler] or the
   functor below.
*)
val clean : t -> unit Deferred.Or_error.t

(**
   This is a wrapper for the similar module in Ocaml_dynloader that takes care of cleaning
   the compiler afterwards.
*)
module Make : functor (X : Ocaml_dynloader.Module_type) -> sig

  val load_ocaml_src_files : (
    string list -> X.t Deferred.Or_error.t
  ) create_arguments

end

(**
   In some cases, we are not interested by the module, but rather because it uses
   a side effect registering mechanism.
*)
val load_ocaml_src_files : (
  string list -> unit Deferred.Or_error.t
) create_arguments
