open Core.Std
open Async.Std

let tar_id = "dynlink.tgz"

let ocamlopt_opt = Ocaml_dynloader.ocamlopt_opt
let camlp4o_opt = Ocaml_dynloader.camlp4o_opt

let pervasives = "pervasives.cmi"
let config_file = "config.sexp"

let mandatory_embedded_files = [
  ocamlopt_opt;
  pervasives;
]

module Directory = struct
  type t = {
    (* invariant here: directory is always an absolute pathname *)
    working_dir : string;
    files : string list;
  } with fields
end

type t = {
  loader : Ocaml_dynloader.t;
  initialize : Directory.t Or_error.t Lazy_deferred.t;
} with fields

let force_initialize (type a) t (with_dir : Directory.t -> a) : a Deferred.Or_error.t =
  Lazy_deferred.force_exn t.initialize >>|? with_dir

let directory t = force_initialize t Directory.working_dir

let read_directory t =
  Lazy_deferred.wait_exn t.initialize >>|? Directory.working_dir

let clean t =
  (* Since we put the archive in the dynloader's tmp dir, we don't have to clean anything
     ourselves. *)
  Ocaml_dynloader.clean t.loader

let force t = force_initialize t ignore

(* This external declaration should be implemented by the c files generated by
   by calling the omakeroot function OCamlPluginEmbeddedArchive.
   Calling this function takes 10 or 20ms => I won't bother avoiding the copying
   from C to caml. *)
external archive : unit -> string = "ocaml_plugin_archive"

let () =
  match Core.Std.Sys.getenv "OCAML_PLUGIN_DUMP_ARCHIVE" with
  | None -> ()
  | Some _ ->
    (* This is a way of extracting the archive from the executable. It can be used like
       this: OCAML_PLUGIN_DUMP_ARCHIVE= ./run.exe | tar -xz
       We exit to avoid running any side effects that could be done later at toplevel. *)
    Printf.printf "%s%!" (archive ());
    Core.Caml.Pervasives.exit 0

let save_archive_to destination =
  Shell.Deferred.Or_error.try_with (fun () ->
    Writer.save destination ~contents:(archive ())
  )

exception Mandatory_file_not_found of string * string list with sexp

(* Because the directory is empty before check_mandatory_files is called (modulo the
   archive itself), it can return the contents of the archive simply by reading everything
   in the directory (assuming the archive doesn't contain directories). *)
let check_mandatory_files working_dir =
  let fct () =
    Sys.readdir working_dir
    >>| function content_of_working_dir ->
    let files = Array.to_list content_of_working_dir in
    let iter file =
      if not (List.mem ~equal:String.equal files file)
      then raise (Mandatory_file_not_found (file, files))
    in
    List.iter ~f:iter mandatory_embedded_files;
    files
  in
  Shell.Deferred.Or_error.try_with ~extract_exn:true fct

type 'a create_arguments = 'a Ocaml_dynloader.create_arguments

let create
    ?in_dir
    ?include_directories
    ?custom_warnings_spec
    ?cmx_flags
    ?cmxs_flags
    ?trigger_unused_value_warnings_despite_mli
    ?use_cache
    ?run_plugin_toplevel
    () =
  let initialize = ref None in
  let initialize_compilation_callback ~directory:working_dir =
    let get_compilation_config working_dir =
      Shell.Deferred.Or_error.try_with ~extract_exn:true (fun () ->
        Reader.load_sexp_exn (working_dir ^/ config_file) Ocaml_dynloader.Config.t_of_sexp
      )
    in
    let deferred =
      let destination = working_dir ^/ tar_id in
      save_archive_to destination >>=? fun () ->
      Tar.extract ~working_dir destination >>=? fun () ->
      check_mandatory_files working_dir >>= function
      | Error exn ->
        Shell.rm ~r:() ~f:() [ working_dir ] >>=? fun () ->
        Deferred.return (Error exn)
      | Ok files ->
        let directory = {
          Directory.
          working_dir;
          files;
        } in
        Deferred.return (Ok directory)
    in
    initialize := Some deferred;
    deferred >>=? fun dir ->
    if List.mem dir.Directory.files config_file
    then get_compilation_config dir.Directory.working_dir >>|? Option.some
    else Deferred.return (Ok None)
  in
  let ocamlopt_opt = "." ^/ ocamlopt_opt in
  let camlp4o_opt = "." ^/ camlp4o_opt in
  let nostdlib flags = "-nostdlib" :: Option.value ~default:[] flags in
  let cmx_flags = nostdlib cmx_flags in
  let cmxs_flags = nostdlib cmxs_flags in
  Ocaml_dynloader.create
    ?in_dir
    ?include_directories
    ?custom_warnings_spec
    ~cmx_flags
    ~cmxs_flags
    ?trigger_unused_value_warnings_despite_mli
    ?use_cache
    ?run_plugin_toplevel
    ~initialize_compilation_callback
    ~ocamlopt_opt
    ~camlp4o_opt
    () >>=? fun loader ->
  let initialize =
    let def = Ocaml_dynloader.compilation_config loader in
    Lazy_deferred.follow def (function
    | Error _ as error -> Deferred.return error
    | Ok _ ->
      match !initialize with
      | None -> assert false
      | Some def -> def
    )
  in
  let compiler = {
    loader;
    initialize;
  } in
  Deferred.return (Ok (`this_needs_manual_cleaning_after compiler))

let with_compiler
    ?in_dir
    ?include_directories
    ?custom_warnings_spec
    ?cmx_flags
    ?cmxs_flags
    ?trigger_unused_value_warnings_despite_mli
    ?use_cache
    ?run_plugin_toplevel
    ()
    ~f
    =
  create
    ?in_dir
    ?include_directories
    ?custom_warnings_spec
    ?cmx_flags
    ?cmxs_flags
    ?trigger_unused_value_warnings_despite_mli
    ?use_cache
    ?run_plugin_toplevel
    ()
    >>=? function `this_needs_manual_cleaning_after compiler ->
  Shell.Deferred.Or_error.try_with_join ~extract_exn:true (fun () -> f compiler)
  >>= fun result ->
  clean compiler >>=? fun () ->
  Deferred.return result

let make_load_ocaml_src_files load_ocaml_src_files =
  let aux
      ?in_dir
      ?include_directories
      ?custom_warnings_spec
      ?cmx_flags
      ?cmxs_flags
      ?trigger_unused_value_warnings_despite_mli
      ?use_cache
      ?run_plugin_toplevel
      files =
    let f compiler =
      let loader = loader compiler in
      load_ocaml_src_files loader files
    in
    with_compiler
      ?in_dir
      ?include_directories
      ?custom_warnings_spec
      ?cmx_flags
      ?cmxs_flags
      ?trigger_unused_value_warnings_despite_mli
      ?use_cache
      ?run_plugin_toplevel
      ()
      ~f
  in
  aux

module Make (X:Ocaml_dynloader.Module_type) = struct
  module M = Ocaml_dynloader.Make(X)
  let load_ocaml_src_files = make_load_ocaml_src_files M.load_ocaml_src_files
end

let load_ocaml_src_files = make_load_ocaml_src_files Ocaml_dynloader.load_ocaml_src_files
